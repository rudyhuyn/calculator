%language "c++"
%no-lines
%defines
%lex-param {params}
%parse-param { BisonParserParam * params}
%define parser_class_name {Parser}


%left PROG_OR PROG_NOR
%left PROG_XOR
%left PROG_AND PROG_NAND
%left BITSHIFTLEFT BITSHIFTRIGHT
%left PLUS MINUS
%left MULTIPLY DIVIDE MOD
%left PROG_NOT
%token LEFTPARENTHESIS
%token RIGHTPARENTHESIS
%left SIN COS TAN
%left LOG LN
%left CARET
%left SQUAREROOT
%right POWER2 POWER3
%token PI EULER
%token SPACE
%token NUMBER 
%token EQU

%code requires
{
#include "../KeyChained.h"
class BisonParserParam;
}

%union {
    KeyChainedIterator * keys;
    KeyChained * key;
}

%type <keys> command
%type <keys> binary_expr
%type <keys> binary_impl_expr
%type <keys> unary_pre_expr
%type <keys> unary_post_expr
%type <key> binary_operator
%type <key> pre_unary_operator
%type <key> post_unary_operator
%type <key> trigo_function
%type <keys> funcall_expr
%type <keys> prim_expr
%type <keys> Program
%type <keys> NUMBER

%{
#include "pch.h"
#include "../BisonParserParam.h"

using namespace std;
using namespace CalculationManager;

#pragma warning (disable: 4702)
#pragma warning (disable: 4127)
#pragma warning (disable: 4065)
%}
    
%start Program
%%
Program: command
            {
                (*params->callback)($1->begin);
            }
    ;

command
    : binary_expr
            {
                    $$ = $1;
            }
    | binary_expr EQU
            {
                    auto equ = new KeyChained(Command::CommandEQU, nullptr);
                    $$ = $1;
                    $$->last->next = equ;
                    $$->last = equ;
            }
    ;

trigo_function
    : SIN
        {
            $$ = new KeyChained(Command::CommandSIN, nullptr);
        }
    | COS
        {
            $$ = new KeyChained(Command::CommandCOS, nullptr);
        }
    | TAN
        {
            $$ = new KeyChained(Command::CommandTAN, nullptr);
        }
    | LOG
        {
            $$ = new KeyChained(Command::CommandLOG, nullptr);
        }
    | LN
        {
            $$ = new KeyChained(Command::CommandLOG, nullptr);
        }
    ;

binary_operator
    : PLUS
    {
        $$ = new KeyChained(Command::CommandADD, nullptr);
    }
    | MINUS
    {
        $$ = new KeyChained(Command::CommandSUB, nullptr);
    }
    | MULTIPLY
    {
        $$ = new KeyChained(Command::CommandMUL, nullptr);
    }
    | DIVIDE
    {
        $$ = new KeyChained(Command::CommandDIV, nullptr);
    }
    | CARET
    {
        $$ = new KeyChained(Command::CommandPWR, nullptr);        
    }
    | PROG_AND
    {
        $$ = new KeyChained(Command::CommandAnd, nullptr);        
    }
    | PROG_OR
    {
        $$ = new KeyChained(Command::CommandOR, nullptr);        
    }
    | PROG_XOR
    {
        $$ = new KeyChained(Command::CommandXor, nullptr);        
    }
    | PROG_NAND
    {
        $$ = new KeyChained(Command::CommandNand, nullptr);        
    }
    | PROG_NOR
    {
        $$ = new KeyChained(Command::CommandNor, nullptr);        
    }
    | BITSHIFTLEFT
    {
        $$ = new KeyChained(Command::CommandLSHF, nullptr);        
    }
    | BITSHIFTRIGHT
    {
        $$ = new KeyChained(Command::CommandRSHF, nullptr);        
    }
    | MOD
    {
        $$ = new KeyChained(Command::CommandMOD, nullptr);        
    }
    ;

pre_unary_operator
    : MINUS
    {
        $$ = new KeyChained(Command::CommandSIGN, nullptr);
    }
    | PROG_NOT
    {
        $$ = new KeyChained(Command::CommandNot, nullptr);
    }
    | SQUAREROOT
    {
        $$ = new KeyChained(Command::CommandSQRT, nullptr);
    }
    ;

post_unary_operator
    : POWER2
    {
        $$ = new KeyChained(Command::CommandSQR, nullptr);
    }
    | POWER3
    {
        $$ = new KeyChained(Command::CommandCUB, nullptr);
    }
    ;

binary_expr
    : binary_impl_expr
                { 
                    $$ = $1;
                }
    | binary_impl_expr binary_operator binary_expr  
                { 
                    $$->begin = $1->begin;
                    $1->last->next = $2;
                    $2->next = $3->begin;
                    $$->last = $3->last;
                }
    ;

binary_impl_expr
    : unary_pre_expr
            {
                $$ = $1;
            }

unary_pre_expr
    : unary_post_expr
            {
                $$ = $1;
            }
    | pre_unary_operator unary_post_expr
                {
                    $$ = $2;
                    $$->last->next = $1;
                    $$->last = $1;
                }
unary_post_expr
    : funcall_expr
            {
                $$ = $1;

            }
    | funcall_expr post_unary_operator
                {
                    $$ = $1;
                    $$->last->next = $2;
                    $$->last = $2;
                }

funcall_expr
    : prim_expr
                {
                    $$ = $1;
                }
    | trigo_function LEFTPARENTHESIS binary_expr RIGHTPARENTHESIS
                {
                    $3->begin = new KeyChained(Command::CommandOPENP, $3->begin);
                    $$ = $3;
                    $3->last->next = new KeyChained(Command::CommandCLOSEP, $1);
                    $$->last = $1;
                }
    ;

prim_expr
    : NUMBER  
    {
            $$ = $1;
    }
    | PI  
    {
         auto chained = new KeyChainedIterator();
         chained->begin = new KeyChained(Command::CommandPI, nullptr);
         chained->last = chained->begin;
         $$ = chained;
    }
    | EULER  
    {
         auto chained = new KeyChainedIterator();
         chained->begin = new KeyChained(Command::CommandEuler, nullptr);
         chained->last = chained->begin;
         $$ = chained;
    }
    | LEFTPARENTHESIS binary_expr RIGHTPARENTHESIS
                {
                    auto close_parenthesis = new KeyChained(Command::CommandCLOSEP, nullptr);

                    $2->begin = new KeyChained(Command::CommandOPENP, $2->begin);
                    $$ = $2;
                    $2->last->next = close_parenthesis;
                    $$->last = close_parenthesis;
                }
    ;
%%
